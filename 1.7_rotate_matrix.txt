
// Given an image represented by an NxN matrix, where each pixel in the image is 4
// bytes, write a method to rotate the image by 90 degrees. Can you do this in place?

// --------------------------- my implement in C++ ----------------------------------

// #1 Brutal-force, O(N*N). Suppose it's a dextrodotation(右旋). And it also takes
// T(N*N) space.

vector<vector<int>> rotate(const vector<vector<int>> oriMx, int N) {
	vector<int> row(N, 0);
	vector<vector<int>> newMx(N, row);

	for (int i = 0; i < N; ++i)
		for (int j = 0; j < N; ++j)
			newMx[j][N-i-1] = oriMx[i][j];
	
	return newMx;
}

// #2 I think I mistaken the question. Maybe I'm not allowed to use extra space and
// rotate directly. So here's the solution.

vector<vector<int>> rotate(vector<vector<int>> matrix, int N) {
	int temp = 0;
	int layer = double(N)/2 + 0.9;

	for (int i = 0; i < layer; ++i) {
		int midPoint = double(N - 2*i)/2 + 0.9;
		for (int j = 0; j < midPoint; ++j) {
			temp = matrix[i][j];                      // store the top-left
			matrix[i][j] = matrix[i][N-j-1];          // bottom-left to top-left
			matrix[i][N-j-1] = matrix[N-j-1][N-i-1];  // bottom-right to bottom-left
			matrix[N-j-1][N-i-1] = matrix[N-i-1][j];  // top-right to bottom-right
			matrix[N-i-1][j] = temp;                  // place top-right
		}
	}

	return matrix;
}

// ------------------------------- test case ---------------------------------------

matrix1 = {{1,2,3}, {4,5,6}, {7,8,9}} n1 = 3;
matrix2 = {{1,2,3,4}, {5,6,7,8}, {9,10,11,12}, {13,14,15,16}} n2 = 4;

// ---------------------------- original solution in Java --------------------------

// #1, Also the basic way, and the only method. O(N*N).

boolean rotate(int[][] matrix) {
	if (matrix.length = 0 || matrix.length != matrix[0].length) return false;
	int n = matrix.length;
	for (int layer = 0; layer < n /2; layer++) {
		int first = layer;
		int last = n -1 - layer;
		for (int i = first; i < last; i++) {
			int offset = i - first;
			int top = matrix[first][i];

			// left -> top
			matrix[first][i] = matrix[last-offset][first];

			// bottom -> left
			matrix[last-offset][first];

			// right -> bottom
			matrix[last][last-offset] = matrix[i][last];

			// top -> right
			matrix[i][last] = top;
		}
	}
}
